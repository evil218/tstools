= TStools说明书 =
周骋
v1.0, 2011年06月28日
:doctype: book


[dedication]
== 致谢 ==
请允许我在这里占用少量篇幅，
向所有鼓励、帮助我不断完善这个码流分析工具的朋友和组织致以诚挚谢意！

感谢数码视讯，这个公司把我引入了TS流的奇妙世界，在这个领域我学到了很多精彩的知识。
感谢所有试用TStools或浏览本书并提供意见和建议的人们，你们的需求是我完成这个分析工具的强大动力。
最后，感谢我的朋友和家人，感谢他们的理解和支持。

[preface]
== 序言 ==
MPEG-2（运动图像压缩编码国际标准）的系统部分
将一个或更多的音频、视频或其它基本数据流合成单个或多个数据流，以适应存储和传输。
这个开放的、高瞻远瞩的标准在全世界推广的过程中不断发展壮大，
即便在MPEG-2视频编码标准逐渐淡出历史舞台的今天，
它仍然能够承载各种视音频传输需求，在广电、消费等各种专业、非专业领域发挥作用。

TS码流是一串字节序列，表面枯燥的数字背后传输的是美妙的声音与图像。
一旦解码出现异常，我们就需要通过分析，排查码流中的错误。
然而打印在屏幕上的数据就像Matrix（黑客帝国）中满屏绿色的符号，
我们没有直接看懂TS流的能力，因此在诊断码流故障时需要借助码流分析工具。
本书描述的就是一种独具特色的码流分析工具。

== 初识TStools ==
=== TStools的诞生 ===
搞数字电视编解码就要跟码流打交道，分析码流的过程中我一直希望把一些繁琐的操作自动化。
虽然公司有码流分析仪，但几个人共用一个仪器总是不方便，并且有些功能码流分析仪也不支持。

2009年初，我开发的H.264编码器出现PCR异常，非常需要连续记录PCR值以便分析其变化规律。
码流分析仪只关注像PCR间隔和PCR抖动这样的指标，不能连续输出PCR值。
于是TStools的最初版本诞生了——SVN的日志记录了它版本化的日子：4月1日。
当时有tsana、ts2es和tsflt三个工具，因此叫TStools（TS工具集）——是不是有点BusyBox的味道？

- tsana分析TS包头，如果有PCR就提取并打印出来；
- ts2es借用了同事给的一个函数，实现TS到ES的转换（试了一下，好像功能不对）；
- tsflt可以将码流中指定PID的包打印出来。

第2季度，我负责在公司的EMR平台上开发IP发送功能。
代码缺陷和网络问题都会导致丢包，这种小概率事件可能一夜只发生一次，甚至仅在早上上班的时候出现。
因此准确地捕捉丢包事件，对调试工作会有很大帮助。
但是码流分析仪的软件夜里可能会死机，导致拷机实验失败。
因此我在tsana工具中增加了UDP接收模块，跟踪指定PID的CC值，一旦不连续就把系统时间和CC情况打印出来。
如果想同时分析所有PID的丢包情况就要复杂一些了：

- tsana要同时跟踪每一种PID的CC数值——需要建立一个链表记录所有出现过的PID；
- tsana要知道每个PID的类型——空包和PCR包的CC值是不变的。

即使是完整的实现丢包检测都必须做PSI分析，因此我在这个简单的基础上停下来，开始考虑TStools的架构。

=== TStools的基本思路 ===

==== 算法与界面分离 ====
码流分析产生的数据结果很复杂，如何展现给用户是个重要的问题。
针对各种数据特点，图形界面的码流分析软件会使用列表、树、波形图等各种控件展现。
鄙人没有太多艺术细胞，若搞出一个丑丑的图形界面，不仅别人看不上眼，自己用着也难受。
另外搞图形界面需要花大量精力在界面技术上，我更想把精力都用在码流分析算法上。
因此作为一个懒人，我选择文本界面，只是简单地把分析结果打印出来。

image:pic_multi_IF.jpg[多种接口]

这里必须提一下csv文件格式，说它是一种文件格式实在是搞复杂了，
它就是一种文本方式的数据文件，唯一的要求是数据之间用英文逗号隔开。
但是因为这样的规定，像Excel这样的数据处理软件可以直接打开它，开展进一步的数据分析，甚至以图形方式展现数据。
因此csv文件格式是数据能被进一步分析的重要形式，本项目的大部分数据输出都采用逗号分隔，以便保存为csv文件。

虽然我不做图形界面，但是也不想拒绝别人为本项目开发其它形式的界面。
因此本项目的分析代码与文本界面位于不同的模块——如果分析模块封装的很好，别人是可以直接拿来开发界面的。

由于分析模块和文本界面仅处理数据，不涉及任何平台相关的内容，因此项目的可移植性非常好。
我不想把这样的项目局限在Windows平台下，因此在Windows下坚持基于cygwin环境开发，
目前的TStools源代码可以直接在Linux环境下编译运行。

==== 数据文本化 ====
为了同时支持离线分析（TS文件）和在线分析（TS over IP），tsana曾经根据参数格式（文件名/URL地址）选择不同的输入模块。
当时我还把UDP模块的接口封装成文件系统接口的样子，以便tsana能用同样的函数打开两种源。
后来我发现可能的输入方式不止这两种，RTP方式、HTTP方式也可以传输TS流，甚至只要开发一个小盒子就可以支持ASI输入。
难道每增加一种输入方式就要改一次tsana？在shell中，这个问题有更好的解决办法。

Unix下有一个叫做“过滤器”的概念：
每个工具处理stdin（标准输入）传入的内容，产生的结果写给stdout（标准输出），出现的错误写入stderr（标准错误）。
由于“管道”可以实现输入输出重新定向，多个这样的过滤器可以用管道连接起来，完成复杂的任务。
如果把tsana设计成一个过滤器，仅处理从stdin输入的码流，借助管道就可以支持任意形式的输入。

image:pic_pipe.jpg[管道]

采用这个方案需要解决一个衍生问题：二进制形式的TS数据以什么样的格式在管道间传输？
二进制文件由于可读性差，数据定位复杂，传输时需要同步，在Unix世界中被严重鄙视。
大部分过滤器都采用文本格式，一行行地（每行同步一次）传递数据。
因此我设计了catts工具，把二进制形式的TS文件读出来，以文本方式一包一行地发给stdout；
又设计了catip工具，把TS over IP中的UDP包拆开成数个TS包，以文本方式一包一行地发给stdout；
而tsana只是简单的从stdin中一包一行的接收TS包就可以了，它不需要知道是谁在给它码流。
以后如果要增加新的输入形式就写一个catxx就行了，tsana不需要改代码重新编译。
（解释一下cat，这是unix下一个非常普通的工具，它把文本文件读出来输出到stdout。
因为cat不支持二进制格式的TS文件，所以我仿照它写了一个catts）

规定用文本形式一行传送一个TS包还不够明确，具体这一行是什么格式呢？
考虑到阅读方便，TS包中的188（或204）个字节之间要有分隔符，
前面提到的英文逗号自然可以，但是过于密集的逗号还是影响阅读，因此用单个空格做分隔符更好。
于是每个TS包变成了这样的文本行：“?? ?? ?? ... ?? ”，每个字节变成了3个可显字符。
如果catts中使用“printf("%02X ", x)”把数据转换成文本形式，效率就太低了。
对于这样一个固定的转换，使用查表法可以克服TS数据文本化的唯一弊端——效率问题。

当TS包变成文本行时，我忽然发现除了tsana，还可以直接使用Unix下的很多工具直接处理catts的输出：
可以用grep过滤出指定PID的TS包，可以用sed修改某些数据，可以用vim快速定位目标数据......它们都支持强大的正规表达式。
最后一个问题：这些工具的输出还是文本格式，如果想回到二进制格式呢？
于是我设计了tobin工具，把符合上述格式的文本转换回二进制文件（阴阳平衡很重要）。
当tobin出现时，我发现用“catip + tobin”立刻就能实现实时流的录制功能（用VLC录流是需要一点技巧的）。
Unix的小工具思想太强大了！

image:pic_recorder.jpg[录流]

==== 灵活的数据交换 ====
在接口模块与分析模块间用管道传输数据时，仅仅传输TS包的内容是不够的。

- 对于ts文件、IP接收等输入形式，包到达时间的信息已经丢失，包的数据位置信息恰恰是恢复到达时间的重要基础；
- 对于mts/m2ts文件、ASI接收等输入形式，包到达时间的信息和包的数据位置信息都可以直接得到，不需要在分析模块中推算到达时间；
- 对于IP输出形式，包的发送（到达）时间非常重要，直接关系到输出码流的指标好坏。

为此本项目在接口模块与分析模块间设计了一种动态的数据格式，允许选择性地携带上述信息。
在上一节数据文本化的基础上规定：
每行文本中除了传输1个TS包的数据段外，还可以有多个数据段提供与该包相关的附加信息，
所有数据段采用“*标签,数据,”的格式。
[options="header"]
|=====================================================================
| 标签  |含义          |类型       |单位      |说明
| date  |日期          |字符串     |          |YYYY-MM-DD
| time  |时间          |字符串     |          |hh:mm:ss
| tsh   |TS包头数据    |字节序列   |          |4-byte
|  ts   |TS包数据      |字节序列   |          |188-byte
|  af   |AF数据        |字节序列   |          |调整字段数据
| pesh  |PES头数据     |字节序列   |          |
| pes   |PES数据       |字节序列   |          |
|  es   |ES数据        |字节序列   |          |
|  rs   |RS校验数据    |字节序列   |          |16-byte
| addr  |地址          |无符号整数 |byte      |包头距第1包头的字节数
| ats   |ATS计数值     |无符号整数 |(1/27M)秒 |到达时间戳，满0x40000000溢出回0(BlurayDisc)
| cts   |CTS计数值     |无符号整数 |(1/27M)秒 |捕捉时间戳，满2576980377600溢出回0
| stc   |STC计数值     |无符号整数 |(1/27M)秒 |节目时间戳，满2576980377600溢出回0
| pcr   |PCR信息       |逗号分隔   |          |PCR,BASE,EXT,间隔,抖动
| pts   |PTS/DTS信息   |逗号分隔   |          |PTS,间隔,PTS-PCR,DTS,间隔,DTS-PCR
| sec   |section数据   |字节序列   |          |段间隔,段头,段体
| rate  |码率统计      |逗号分隔   |          |PID,码率,PID,码率......
| rats  |系统码率      |逗号分隔   |          |sys,码率,psi-si,码率,0x1FFF,码率
| ratp  |PSI/SI码率    |逗号分隔   |          |psi-si,码率,PID,码率,PID,码率......
| err   |错误信息      |逗号分隔   |          |错误号,说明,错误号,说明......
|  si   |section信息   |逗号分隔   |          |PSI/SI的section内容解析
| tcp   |TCP字段信息   |逗号分隔   |          |ATSC MH流的TCP包字段解析
| src   |本包来源      |字节序列   |          |将来用于复用
|其它 4+|保留，接收端遇到时从该标签一直忽略到下一个标签
|=====================================================================

为了方便看数据，建议先传输ts、trp、data之类的核心数据段，
实际的传输内容是这样的（TS包太长，中间的内容省略了）：

----
*ts,47 00 32 12 ... AD 3F 43 4C,*addr,0,
*ts,47 00 32 13 ... BA 44 39 4A,*addr,188,
----

地址（addr）是输入环节的重要信息：
对于文件，通过地址可以定位数据，找到错误发生的位置；
对于网络等实时流，地址反映了已分析的数据总量。
在传输pes、es片段的场合可以没有地址信息。

时间戳（ats, stc）反映了包的到达（或发送）时间。
对于mts/m2ts文件或硬件实时捕捉的包，时间戳可以用来精确计算PCR抖动等指标；
对于其它没有时间戳的源，分析模块内部会基于码率恒定的假设计算出每个包的STC。
ats时间戳的溢出值是0x40000000；stc时间戳的溢出值是2576980377600（300*(2\^33)）。
接收模块内部根据PCR信息和这个时间戳恢复出STC，所有与时间相关的计算都是基于STC进行的。

== 使用TStools ==

=== 单个工具 ===
Unix下每个工具的使用说明一般要用“--help”来看，
如果你懒得去命令行敲键盘，就看看这些自动生成的链接吧！
翻译成中文有点画蛇添足，说明书还是看原版的好：

catts::
link:catts.html[打开指定的TS文件，将每个TS包转换成TXT格式发送到stdout]
catip::
link:catip.html[接收UDP包，拆成TS包转换成TXT格式发送到stdout]
tsana::
link:tsana.html[从stdin接收TXT格式的TS包，按照参数要求分析，并以TXT格式输出到stdout]
tobin::
link:tobin.html[从stdin接收TXT格式的数据，转换成二进制写入指定文件]
toip::
link:toip.html[从stdin接收TXT格式的数据(需要ATS信息)，转换成二进制，打成UDP包，按照正确的码率发送出去]

=== 组合用法 ===

==== PID成分分析 ====

----
语法：
    catts xxx.ts | tsana [-lst] [-iv 5000]
例子：
    $ catts ~/Videos/stream/1.ts | tsana -c
    0x0000, PAT , program association section
    0x0010, NIT , network information section
    0x0011, SDT , service description section
    0x0030, PMT , program map section
    0x0031, PCR , program counter reference
    0x0032, VID , video packet
    0x0033, AUD , audio packet
    0x0034, AUD , audio packet
    0x1FFF, NUL , empty packet
----

参数“-lst”并不是必须的，因为这是tsana的缺省操作。
输出列表根据PID从小到大排序(视频或音频PID所在的行以彩色方式显示）。

image:pic_PID_list.jpg[PID表]

分析器内部会维护一个PID链表，分析期间遇到的新PID包或者PSI表中声明的PID按照从小到大的顺序插入表中。
因为采用链表，其长度是没有限制的，最多可以有从0x0000到0x1FFF共8192项。
因为插入时是排序的，所以很容易从小到大打印输出。

PID成分分析是最早开发的功能，当时一旦所有PMT分析完成就停下来，输出PID链表。
因此除了PAT、PMT中声明的PID，其它PID是否能分析到取决于PSI分析期间是否能遇到。
最糟糕的情况是：PAT和各个PMT表相继出现，中间没有其它PID包。
这种情况下分析到的PID将仅仅是这些表中所提及的。

由于码流长度的无限性，要分析码流中包含哪些PID，决定什么时候结束分析是个重要问题。
如果码流正常，大部分PID都将在PSI表中声明，因此完成节目分析时已经可以输出PID表了。
但是像SDT、NIT这样的表在PAT、PMT体系中是找不到的，更何况一些码流中会有意无意的出现unknown PID。
因此限定分析时间是个更合理的方案——任何常用的PID至少每秒钟应该出现1次。
根据码流中第1个节目的PCR时间，可以判断分析了多长时间。
tsana有一个“-iv”参数可以设定interval（间隔时间），
最初引入这个参数是为了指明码率分析的时间尺度——间隔时间越短，码率波动越明显。
在本操作中，这个参数可以用来限定节目分析的时间——缺省1000ms已经足够长了，
试试看指定更长的时间，对于某些流，有可能分析到更多PID。

==== 节目树分析 ====

----
语法：
    catts xxx.ts | tsana -psi [-iv 5000]

例子：
    $ catts ~/Videos/stream/1.ts | tsana -c -psi
    transport_stream_id,     1(0x0001)
    program_number,     1(0x0001), PMT_PID, 0x0030, PCR_PID, 0x0031, service_provider, "DVT"(44 56 54), service_name, "ENC1"(45 4E 43 31),
    elementary_PID, 0x0032, stream_type, 0x1B, type, H.264, detail, ITU-T Rec.H.264|ISO/IEC 14496-10 Video,
    elementary_PID, 0x0033, stream_type, 0x03, type, MPEG-1, detail, ISO/IEC 11172-3 Audio,
    elementary_PID, 0x0034, stream_type, 0x03, type, MPEG-1, detail, ISO/IEC 11172-3 Audio,
----

参数“-psi”告诉tsana在完成PSI/SI分析后，把所有节目信息打印出来：

- 码流层信息在第1行，只有一个id；
- 后面每个节目层信息占1行；
- 节目层信息下面每个基本流的信息占1行。

这种每层信息仅占1行的方式有力与用户通过grep筛选自己需要的信息。

- 如果只关心节目级信息，可以用“ | grep "prog"”；
- 如果只关心基本流信息，可以用“ | grep "elem"”；

image:pic_PSI_tree.jpg[PSI树]

分析器内部维护了1个prog链表，链表的每1项有自己的track链表。
在PSI/SI分析的过程中，这些链表因为收集到的信息不断长大。
因为采用链表，这些表的长度没有限制，码流中声明了多少就能放下多少。

最复杂的PSI/SI表由多个section组成，每个section可能分散在多个TS包中。
TStools支持这种因为超长需要多个TS包承载的PSI/SI。

“-psi”仅关注PAT、PMT和SDT的分析，NIT、CAT等其它表的分析参见“-sec”和“-si”参数。
本参数同样可以用“-iv”指定PSI分析时间，时间过短时可能分析不到SDT表。

==== 错误分析 ====

----
语法：catts xxx.ts | tsana -err
----

==== PCR分析 ====

----
语法：catts xxx.ts | tsana -pcr [-pid 0x0101]
----

==== PTS、DTS分析 ====

----
语法：catts xxx.ts | tsana -pts [-pid 0x0101]
----

==== 码率分析 ====

----
语法：catts xxx.ts | tsana -rats
语法：catts xxx.ts | tsana -ratp
语法：catts xxx.ts | tsana -rate [-type vid]
----

==== 导出PES、ES数据 ====

----
语法：catts xxx.ts | tsana -pes [-pid 0x0032] | tobin 32.pes
语法：catts xxx.ts | tsana -es [-pid 0x0032] | tobin 32.es
----

==== 实时流录制 ====

----
语法：catip udp://@:1234 | tobin xxx.ts
语法：catip udp://@224.165.54.31:1234 | tobin xxx.ts
----

== 深入了解TStools ==

=== TS同步 ===

catts读入的ts文件有可能不是TS同步的——前面有不完整的包数据，
有可能不是188字节包长的——204字节包长。
对于这些情况，让用户猜测后以参数的方式输入固然可以，但是用起来会很不方便。
工具catts有内置judge_type()函数自动处理这两种情况——对于非TS文件可以用“-n”和“--no-sync”参数关闭该功能。

image:pic_TS_sync.jpg[码流同步]

如图示，judge_type()函数采用了状态机实现这个功能。
在每个状态下，先用fread()函数读1个字节，根据这个字节是否是0x47，决定文件指针的移动和状态的变化。
目前状态机在连续3个0x47位置正确时认为同步成功——需要的话可以改成更多个0x47。
因此除了FILE_BIN外，有4个判断同步字节的状态：FILE_UNKNOWN、FILE_TS、FILE_MTS、FILE_TSRS。

- FILE_UNKNOWN：匹配包头后进入FILE_TS检测状态，若前4096-byte匹配失败就认为是BIN文件；
- FILE_TS：若间隔为188的连续3个包头匹配成功就认为是TS文件，否则进入FILE_MTS检测状态；
- FILE_MTS：若间隔为192的连续3个包头匹配成功就认为是MTS文件，否则进入FILE_TSRS检测状态；
- FILE_TSRS：若间隔为204的连续3个包头匹配成功就认为是TSRS文件，否则进入FILE_UNKNOWN检测状态；

知道文件格式的同时就知道了开头处应该忽略的字节数，调整文件指针到第一个同步字节处，即可开展后继处理。

=== 时钟恢复 ===

码流的各种时钟：

- STC：节目时钟：TS的每个节目的视音频所参考的时钟（可能多个节目共享同一个STC）。
- MTC：复用时钟：TS的所有包发收复用时所参考的时钟（与所有STC速度成正比，可能与某个STC一致）。

码流的各种时间戳：

- PCR：节目时间戳（参考STC）：TS的每个节目供接收端恢复STC的数据（解析可获得，可能有抖动偏差）。
- DTS：解码时间戳（参考STC）：理想解码器对视音频帧的解码时刻（与PTS相等时仅传输PTS）。
- PTS：回放时间戳（参考STC）：理想解码器对视音频帧的回放时刻（解析可获得，无偏差，可能不合理）。
- ITS：理想时间戳（参考MTC）：没有任何误差的理想复用时间戳（鄙人的定义和命名）。
- STS：发送时间戳（参考MTC）：理想复用器的STS可作为ITS使用（码流中不含此信息）。
- ATS：到达时间戳（参考MTC）：这是BD标准中为每个包定义的的时间戳，可作为ITS使用。
- CTS：捕捉时间戳（参考MTC）：如果信道指标完美，CTS与STS速度成正比（注意收发时钟速度有偏差）。

在分析码流的PCR指标（或进行复用/解复用）时，每个包的时间戳信息情况：

- ts文件没有与MTC相关的时间戳；
- mts/m2ts文件在每个TS包前用4个字节标识ATS，可作为ITS使用；
- ASI/RF传输时，信道延迟恒定，接收端可以得到每个包的CTS，可作为ITS使用；
- TSoverIP把多个TS包打成1个UDP包，且信道延迟不定，因此每个包的CTS非常不准确；
- MTSoverIP在每个包前携带ATS，可作为ITS使用；

image:pic_STC.jpg[STC恢复]

如上图，只要知道x包所在节目前面的2个PCR包（a和b），就能根据ITS比例计算x包的STC时刻。
这里，ITS的具体数值不重要，重要的是ITS比例。

对于ts文件和TSoverIP：
如果系统码率稳定，可以认为拉匀后每个包是恒定间隔到达的，则每个包的ADD（地址）比例等于ITS比例；
如果系统码率变化，就没有好办法获得ITS比例了。

对于mts/m2ts文件和MTSoverIP：ATS比例等于ITS比例。

对于ASI/RF：CTS比例等于ITS比例。

本项目的核心模块正是基于这样的原理计算b包与c包间每个包的STC：

- 假设a包和b包的PCR抖动为0，根据ITS比例可以推导x包的STCx。
- 若增加a包与b包的距离（跨过n个PCR包），可利用平均作用减弱a包与b包的实际PCR抖动引起的误差。
- 当携带第3个PCR的c包出现时，根据推导出的STCc和该包的PCR值可以计算该包的PCR抖动。
- 丢弃a包的信息，假设c包的PCR抖动为0，c包后面的包根据b包和c包计算。
- 对于多节目流，不同节目的TS包的STC是基于它们各自的PCR计算的。
- 由于除PMT之外的PSI/SI包和空包不属于任何节目，其STC基于某个节目的PCR计算（缺省为PAT中第1个节目）。

先写这些吧！
朋友们要是发现了BUG，或者有什么好的意见和建议，可以通过mailto:zhoucheng@tsinghua.org.cn[周骋]联系我。

[appendix]
== 附录 ==
One or more optional appendixes go here at section level 1.

[bibliography]
== 参考资料 ==

[bibliography]
.Books
- [[[DTV]]] 张刚. '深入浅出数字电视'. 电子工业出版社. ISBN 978-7-121-03908-9.

[bibliography]
.Articles
- [[[ISO]]] ISO/IEC 2000. 'ISO/IEC 13818-1', ISO/IEC 2000. 2000-12-01.


[glossary]
== 术语表 ==

[glossary]
STC::
  System Time Clock.

PCR::
  Program Clock Reference.

////////////////////////////////////////////////////////////////
[colophon]
== 出版商 ==
Sumavision

[index]
== 索引 ==
The index is normally left completely empty, it's contents being
generated automatically by the DocBook toolchain.
////////////////////////////////////////////////////////////////
