/* vim: set tabstop=8 shiftwidth=8:
 * name: udp.c
 * funx: UDP access
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "config.h" /* for SYS_* macro, generated by configure */

#ifdef SYS_WINDOWS
#       define WIN32_LEAN_AND_MEAN
#       include <winsock2.h>
#       include <ws2tcpip.h>
typedef int socklen_t;
#else /* unix-like PLATFORM */
#       include <sys/types.h>
#       include <sys/socket.h>
#       include <netinet/in.h>
#       include <arpa/inet.h> /* for inet_ntoa(), inet_addr(), etc */
#       include <unistd.h> /* for close() */
#       include <fcntl.h> /* for fcntl(), O_NONBLOCK, etc */
#       include <sys/select.h> /* for select(), etc */
#       include <errno.h>
#       define __USE_GNU /* for 'struct ip_mreq' in CentOS x64 */
#endif

#include "common.h"
#include "udp.h"

static int rpt_lvl = WRN_LVL; /* report level: ERR, WRN, INF, DBG */

#define UDP_LENGTH_MAX (1536)

struct udp {
        int sock;
        struct sockaddr_in remote;
        socklen_t socklen;

        char addr[32];
        char src_addr[32]; /* for IGMP v3 */
};

static int report(const char *str);

intptr_t udp_open(char *src_addr, char *addr, unsigned short port, char *mode)
{
        struct udp *udp;

        udp = (struct udp *)malloc(sizeof(struct udp));
        if(NULL == udp) {
                RPTERR("malloc failed");
                return (intptr_t)NULL;
        }

        strcpy(udp->addr, addr);

        udp->src_addr[0] = '\0';
        if(src_addr) {
                strcpy(udp->src_addr, src_addr);
        }

#ifdef SYS_WINDOWS
        WSADATA wsaData;
        if(WSAStartup(MAKEWORD(1,1), &wsaData) == SOCKET_ERROR)
        {
                RPTERR("WSAStartup error");
                return (intptr_t)NULL;
        }
#endif

        /* build socket */
        if((udp->sock = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
                report("socket failed");
                return (intptr_t)NULL;
        }

        /* nonblock mode */
#ifdef SYS_WINDOWS
        {
                unsigned long opt = 1;
                ioctlsocket(udp->sock, FIONBIO, &opt);
        }
#else
        {
                fcntl(udp->sock, F_SETFL, O_NONBLOCK);
        }
#endif

        /* reuse address */
        {
                int reuseaddr = 1; /* nonzero means enable */

                setsockopt(udp->sock, SOL_SOCKET, SO_REUSEADDR,
                           (char *)&reuseaddr, (socklen_t)sizeof(int));
        }

        /* name the socket */
        {
                struct sockaddr_in local;

                memset(&local, 0, sizeof(local)); /* for some special compile environment */
                local.sin_family = AF_INET;
                local.sin_addr.s_addr = htonl(INADDR_ANY);
                local.sin_port = ('r' == mode[0]) ? htons(port) : 0;

                if(bind(udp->sock, (struct sockaddr *)&local, (socklen_t)sizeof(struct sockaddr)) < 0) {
                        report("bind failed");
                        fprintf(stderr, "addr: %s, port: %d\n",
                            inet_ntoa(local.sin_addr),
                            (int)ntohs(local.sin_port));
                        return (intptr_t)NULL;
                }
        }

        /* set the remote */
        if('w' == mode[0])
        {
                udp->remote.sin_family = AF_INET;
                udp->remote.sin_addr.s_addr = inet_addr(addr);
                udp->remote.sin_port = htons(port);
        }

        /* manage multicast */
        if(IN_MULTICAST(ntohl(inet_addr(udp->addr)))) {
                if('\0' == udp->src_addr[0]) {
                        struct ip_mreq imreq;

                        RPTINF("IP_ADD_MEMBERSHIP: %s", udp->addr);
                        imreq.imr_interface.s_addr = htonl(INADDR_ANY);
                        imreq.imr_multiaddr.s_addr = inet_addr(udp->addr);
                        if(setsockopt(udp->sock, IPPROTO_IP, IP_ADD_MEMBERSHIP,
                                      (char *)&imreq, (socklen_t)sizeof(imreq)) != 0) {
                                report("IP_ADD_MEMBERSHIP failed");
                        }
                }
                else {
                        struct ip_mreq_source mreqsrc;

                        RPTINF("IP_ADD_SOURCE_MEMBERSHIP: %s@%s", udp->src_addr, udp->addr);
                        mreqsrc.imr_interface.s_addr = htonl(INADDR_ANY);
                        mreqsrc.imr_multiaddr.s_addr = inet_addr(udp->addr);
                        mreqsrc.imr_sourceaddr.s_addr = inet_addr(udp->src_addr);
                        if(setsockopt(udp->sock, IPPROTO_IP, IP_ADD_SOURCE_MEMBERSHIP,
                                      (char *)&mreqsrc, (socklen_t)sizeof(mreqsrc)) != 0) {
                                report("IP_ADD_SOURCE_MEMBERSHIP failed");
                        }
                }
        }

        udp->socklen = (socklen_t)sizeof(struct sockaddr_in);
        return (intptr_t)udp;
}

int udp_close(intptr_t id)
{
        struct udp *udp = (struct udp *)id;

        if(NULL == udp) {
                RPTERR("bad id");
                return -1;
        }

        /* manage multicast */
        if(IN_MULTICAST(ntohl(inet_addr(udp->addr)))) {
                if('\0' == udp->src_addr[0]) {
                        struct ip_mreq imreq;

                        RPTINF("IP_DROP_MEMBERSHIP: %s", udp->addr);
                        imreq.imr_interface.s_addr = htonl(INADDR_ANY);
                        imreq.imr_multiaddr.s_addr = inet_addr(udp->addr);
                        if(setsockopt(udp->sock, IPPROTO_IP, IP_DROP_MEMBERSHIP,
                                      (char *)&imreq, (socklen_t)sizeof(imreq)) != 0) {
                                report("IP_DROP_MEMBERSHIP failed");
                        }
                }
                else {
                        struct ip_mreq_source mreqsrc;

                        RPTINF("IP_DROP_SOURCE_MEMBERSHIP: %s@%s", udp->src_addr, udp->addr);
                        mreqsrc.imr_interface.s_addr = htonl(INADDR_ANY);
                        mreqsrc.imr_multiaddr.s_addr = inet_addr(udp->addr);
                        mreqsrc.imr_sourceaddr.s_addr = inet_addr(udp->src_addr);
                        if(setsockopt(udp->sock, IPPROTO_IP, IP_DROP_SOURCE_MEMBERSHIP,
                                      (char *)&mreqsrc, (socklen_t)sizeof(mreqsrc)) != 0) {
                                report("IP_DROP_SOURCE_MEMBERSHIP failed");
                        }
                }
        }

        /* close socket*/
#ifdef SYS_WINDOWS
        closesocket(udp->sock);
        WSACleanup();
#else
        close(udp->sock);
#endif

        free(udp);
        return 0;
}

ssize_t udp_read(intptr_t id, void *buf)
{
        struct udp *udp = (struct udp *)id;
        ssize_t rslt = 0;
        fd_set fds;

        if(NULL == udp) {
                RPTERR("bad id");
                return -1;
        }

        FD_ZERO(&fds);
        FD_SET(udp->sock, &fds);
        if(select(udp->sock + 1, &fds, NULL, NULL, NULL) < 0) {
                report("select failed");
                return 0;
        }

        if(FD_ISSET(udp->sock, &fds)) {
                rslt = recvfrom(udp->sock, buf, UDP_LENGTH_MAX, 0,
                                (struct sockaddr *)&(udp->remote),
                                &(udp->socklen));
        }

        return rslt;
}

ssize_t udp_write(intptr_t id, const void *buf, size_t len)
{
        struct udp *udp = (struct udp *)id;
        ssize_t rslt = 0;

        if(NULL == udp) {
                RPTERR("bad id");
                return -1;
        }

        rslt = sendto(udp->sock, buf, len, 0,
                        (struct sockaddr *)&(udp->remote),
                        udp->socklen);

        return rslt;
}

static int report(const char *str)
{
        int err;

#ifdef SYS_WINDOWS
        err = WSAGetLastError();
#else
        err = errno;
#endif
        RPTERR("%s, errno: %d", str, err);
        return 0;
}
