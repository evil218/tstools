/* vim: set tabstop=8 shiftwidth=8:
 * name: toip.c
 * funx: send UDP packet with text data in stdin
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h> /* for strcmp, etc */
#include <inttypes.h> /* for PRId64, etc */
#include <sys/time.h> /* for gettimeofday(), etc */

#include "config.h" /* for SYS_* macro, generated by configure */

#ifdef SYS_WINDOWS
#       include <winsock.h>
#       define timeradd(a, b, result) \
                do { \
                        (result)->tv_sec = (a)->tv_sec + (b)->tv_sec; \
                        (result)->tv_usec = (a)->tv_usec + (b)->tv_usec; \
                        if ((result)->tv_usec >= 1000000) \
                        { \
	                        ++(result)->tv_sec; \
	                        (result)->tv_usec -= 1000000; \
                        } \
                } while (0)
#else /* unix-like PLATFORM */
#       include <sys/select.h> /* for select(), etc */
#endif

#include "tstool_config.h"
#include "common.h"
#include "if.h"
#include "url.h"
#include "ts.h"

static int rpt_lvl = WRN_LVL; /* report level: ERR, WRN, INF, DBG */

static struct url *fd_o = NULL;
static char file_o[FILENAME_MAX] = "";

static int deal_with_parameter(int argc, char *argv[]);
static void show_help();
static void show_version();

int main(int argc, char *argv[])
{
        int cnt;
        char tbuf[LINE_LENGTH_MAX + 10]; /* txt data buffer */
        uint8_t bbuf[188 * 7 + 10]; /* bin data buffer */
        char *tag;
        char *pt;
        uint8_t *pb = bbuf;

        struct timeval tv_pkt; /* packet time */
        struct timeval tv_cur; /* current time */

        long long int data;
        int64_t lATS = 0LL; /* last ATS */
        int64_t ATS = 0LL; /* current ATS */
        int64_t dATS = 0LL; /* delta ATS */
        int64_t *ats = NULL; /* NULL means without ATS data */

        if(0 != deal_with_parameter(argc, argv)) {
                return -1;
        }

        fd_o = url_open(file_o, "wb");
        if(NULL == fd_o) {
                RPTERR("open \"%s\" failed", file_o);
                return -1;
        }

        /* init time, then wait until delta ATS OK */
        gettimeofday(&tv_pkt, NULL);
        gettimeofday(&tv_cur, NULL);
        while(NULL != fgets(tbuf, LINE_LENGTH_MAX, stdin)) {
                pt = tbuf;
                ats = NULL;
                while(0 == next_tag(&tag, &pt)) {
                        if(0 == strcmp(tag, "*ats")) {
                                next_nuint_hex(&data, &pt, 1);
                                ATS = (int64_t)data;
                                ats = &ATS;
                                dATS = ts_timestamp_diff(ATS, lATS, ATS_OVF);
                                lATS = ATS;
                        }
                }
                if(!ats) {
                        RPTERR("TS packet without ATS");
                        url_close(fd_o);
                        return -1;
                }
                if(0 < dATS && dATS < 100 * ATS_MS) {
                        /* delta ATS is OK now */
                        break;
                }
        }

        /* run */
        while(NULL != fgets(tbuf, LINE_LENGTH_MAX, stdin)) {
                pt = tbuf;
                ats = NULL;
                while(0 == next_tag(&tag, &pt)) {
                        if(0 == strcmp(tag, "*ts")) {
                                cnt = next_nbyte_hex(pb, &pt, LINE_LENGTH_MAX / 3);
                                pb += cnt;
                        }
                        if(0 == strcmp(tag, "*ats")) {
                                struct timeval dtv;
                                struct timeval tv_new;

                                next_nuint_hex(&data, &pt, 1);
                                ATS = (int64_t)data;
                                ats = &ATS;
                                dATS = ts_timestamp_diff(ATS, lATS, ATS_OVF);
                                if(0 < dATS && dATS < 100 * ATS_MS) {
                                        dtv.tv_sec = dATS / ATS_1S;
                                        dATS %= ATS_1S;
                                        dtv.tv_usec = dATS / ATS_US;
                                        dATS %= ATS_US;
                                        timeradd(&tv_pkt, &dtv, &tv_new);
                                        tv_pkt = tv_new;
                                        lATS = ts_timestamp_add(ATS, -dATS, ATS_OVF);
                                }
                                else {
                                        RPTWRN("!(0 < dATS < 100ms): %" PRId64, dATS);
                                        gettimeofday(&tv_pkt, NULL);
                                        lATS = ATS;
                                }
                        }
                }
                if(!ats) {
                        RPTERR("TS packet without ATS");
                        url_close(fd_o);
                        return -1;
                }
                if((pb - bbuf) >= (188 * 7)) {
                        url_write(bbuf, pb - bbuf, 1, fd_o);
                        pb = bbuf;
                        if(timercmp(&tv_pkt, &tv_cur, >)) {
                                struct timeval delay; /* send interval */

                                delay.tv_sec = 0;
                                delay.tv_usec = 5000; /* us */
                                select(0, NULL, NULL, NULL, &delay); /* sleep */
                                gettimeofday(&tv_cur, NULL);
                        }
                }
        }

        url_close(fd_o);
        return 0;
}

static int deal_with_parameter(int argc, char *argv[])
{
        int i;

        if(1 == argc) {
                /* no parameter */
                fprintf(stderr, "No URL to process...\n\n");
                show_help();
                return -1;
        }

        for(i = 1; i < argc; i++) {
                if('-' == argv[i][0]) {
                        if(0 == strcmp(argv[i], "-h") ||
                           0 == strcmp(argv[i], "--help")) {
                                show_help();
                                return -1;
                        }
                        else if(0 == strcmp(argv[i], "-v") ||
                                0 == strcmp(argv[i], "--version")) {
                                show_version();
                                return -1;
                        }
                        else {
                                RPTERR("wrong parameter: %s", argv[i]);
                                return -1;
                        }
                }
                else {
                        strcpy(file_o, argv[i]);
                }
        }

        return 0;
}

static void show_help()
{
        fprintf(stdout,
                "'toip' read from stdin, convert to UDP, send to IP according to ATS.\n"
                "\n"
                "Usage: toip [OPTION] udp://@xxx.xxx.xxx.xxx:xxxx [OPTION]\n"
                "\n"
                "Options:\n"
                "\n"
                " -h, --help       print this information only\n"
                " -v, --version    print my version only\n"
                "\n"
                "Examples:\n"
                "  catts *.mts | toip udp://@:1234\n\n"
                "  catts *.mts | toip udp://@224.165.54.210:1234\n\n"
                "  catts *.ts | tsana -ts -ats | toip udp://@:1234\n\n"
                "\n"
                "Report bugs to <zhoucheng@tsinghua.org.cn>.\n");
        return;
}

static void show_version()
{
        fprintf(stdout,
                "toip of tstools v%s (%s)\n"
                "Build time: %s %s\n"
                "\n"
                "Copyright (C) 2009,2010,2011,2012 ZHOU Cheng.\n"
                "License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\n"
                "This is free software; contact author for additional information.\n"
                "There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR\n"
                "A PARTICULAR PURPOSE.\n"
                "\n"
                "Written by ZHOU Cheng.\n",
                VERSION_STR, REVISION, __DATE__, __TIME__);
        return;
}
